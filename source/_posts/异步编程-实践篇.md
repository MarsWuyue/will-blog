---
title: 异步编程-实践篇
tag: 
    - 异步编程
    - Asynchronous
    - async/await
categories: 异步编程
---

## 异步编程没有被广泛应用吗

我在[异步编程-扫盲篇](https://marswuyue.github.io/will-blog/2020/04/20/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E6%89%AB%E7%9B%B2%E7%AF%87/)中分析了同步和异步编程的模式，并且也进行了比较，既然异步有那么多的好处，那么他为什么没有被广泛应用呢？其实在WPF和Winform应用中，异步已经被广泛应用了，比如按钮点击事件，这些都是异步操作，否则用户点一个按钮就卡住一会，体验得多差？但是在ASP.NET中似乎大家还是更中意使用同步模式，我分析有以下几点原因：

1. 同步编程模式更加符合人的思考模式
2. 异步代码“难维护”，“难调试”
3. 没有真正了解异步的原理，不敢用
4. 不想在业务代码中到处嵌套Task.Run等代码

## 如何写出优雅的异步代码-最佳实践

可能是微软也意识到了上面开发人员遇到的问题，所以在ASP.NET 4.5中，引入了async/await，使用了他们的代码就几乎跟开发同步代码一样简单了，下面我们来看一下如何使用async/await来写出优雅的异步代码吧。

```c#
/// 添加一个用户
public async Task SaveUser(UserInfo user)
{
    return await repo.saveUser(user);
}

/// 根据userId获取用户信息
public async Task<UserInfo> GetUser(stirng userId)
{
    return await repo.GetUser(userId);
}
```

好了，只需要加上async和await，你就写好一个异步方法了，看起来很简单，那么下面我们通过对***GetUser***方法的一步一步扩展来了解以下异步编程的注意事项。

### 分析代码的执行原理

```c#
/// 根据userId获取用户信息
/// repo.GetUser(userId)是一个异步访问数据库的方法
public async Task<UserInfo> GetUser(stirng userId)
{
    var user = await repo.GetUser(userId);
    return new UserDTO(user);
}
```

我对***GetUser***这个方法加了一点点逻辑，需要将数据库返回的***user***转化为DTO进行传输。假设***GetUser***是Controller层，我们来分析一下代码的执行路径。
首先，系统接到客户端请求，从线程池中取出线程a，接收请求，执行***GetUser***方法。当系统运行到```var user = await repo.GetUser(userId);```这句代码，发现了await关键字，于是线程a在调用```repo.GetUser(userId)```后立刻返回线程池，并且把自己变成可用状态。当系统收到数据库查询完毕的通知后，再次从线程池中取出一个可用线程b，来处理```var user = await repo.GetUser(userId);```后续代码，即将***user***转换成***UserDTO***并返回给客户端。
> 敲黑板：
>
> 1. 线程b和线程a可能是同一个线程，也可能是不同线程，系统会根据await那句代码的执行时间来判断是否让线程a返回线程池
> 2. 系统并不是在运行时才处理***await***关键字的，上面的描述只是为了让大家更易于理解，其实是在编译时就将这段代码编译成了状态机，具体实现细节可以参考***[CLR via C#(第4版)](https://book.douban.com/subject/26285940/)***中的“***28.3 编译器如何将异步函数转换成状态机***”。

### Context丢失问题
  
看了上面执行原理的分析，大家应该会注意到一个问题，就是线程切换。执行***await***前后代码可能会使用不同的线程，通过下面的例子我们看一下线程切换带来的影响。

```c#
/// 根据userId获取用户信息
/// repo.GetUser(userId)是一个异步访问数据库的方法
public async Task<UserInfo> GetUser(stirng userId)
{
    var context1 = HttpContext.Current;
    var user = await repo.GetUser(userId);
    var context2 = HttpContext.Current;
    return new UserDTO(user);
}
```

注意上面的代码，我们使用了***HttpContext***，此时如果线程a和线程b不是同一个线程，那么你会发现***context1***有值，而***context2***为null。所以在这种情况下尽量避免使用同步上下文。
***Note：这种上下文丢失未必发上，参考前面的“敲黑板2”，如果操作非常快，系统可能并未进行线程切换，此时上下文不会丢失***

### 为什么要求Async All the Way

讨论完同步上下文的问题，我们继续看一下怎么写一个死锁代码。还是刚才的例子：

```c#
/// 这是一个同步方法
public void Test()
{
    var userTask = GetUser("fakeUserId");
    userTask.Result();
}
/// 根据userId获取用户信息
/// repo.GetUser(userId)是一个异步访问数据库的方法
public async Task<UserInfo> GetUser(stirng userId)
{
    return await repo.GetUser(userId);
}
```

看一下上面的经典死锁代码，是不是看上去没什么问题？下面我们来分析一下他是怎么导致死锁的。
首先，当我调用***Test***方法的时候，假设由线程a执行，当运行到***await***时，await处理上下文的方式是在任务没有完成的时候，捕获当前上下文，等待任务完成进行方法的恢复，由于***Test***是同步代码，因此线程a始终没有释放，处于挂起状态，这时候当await的代码执行完成，他用之前捕获的上下文去恢复执行，由于one-chunk-at-a-time的机制，当前上下文中已经有一个线程a，所以系统会使用线程a去恢复执行，但是线程a又正在等待await的完成，这就导致了他们两个在互相等待的情况，于是就产生了死锁。

那么为什么异步方法不会产生这个问题呢？根据我们上面的“分析代码的执行原理”部分可以知道，对于异步方法，当执行器看到***await***的时候，他会执行await方法，同时释放当前线程。等await方法执行完成，他会通过当前上下文唤起方法继续执行，此时当前上下文中就不存在线程，那么CLR会从线程池中取出一个空闲线程继续执行后面的方法，因此不存在死锁。

所以我们如果使用异步，就应该从头到尾异步，这也说明了如果对一个同步代码进行异步重构，建议的方式是纵向重构。

### 什么时候使用ConfigureAwait

看完死锁的例子，因为await代码捕获了当前上下文导致的，那么除了“Async All the Way”，我们还有个方法可以避免死锁，就是强制切换上下文。

```c#
/// 这是一个同步方法
public void Test()
{
    var userTask = GetUser("fakeUserId");
    userTask.Result();
}
/// 根据userId获取用户信息
/// repo.GetUser(userId)是一个异步访问数据库的方法
public async Task<UserInfo> GetUser(stirng userId)
{
    return await repo.GetUser(userId)
        .ConfigureAwait(false);
}
```

再看一下上面的代码，我在await后面加了个```.ConfigureAwait(false)```，这句代码的意思是使await代码的执行不使用当前上下文，这样就避免了死锁的产生。当然强制的上下文切换会导致在执行await后面的代码丢失上下文。

官方建议我们在使用异步编程的时候，只要你能够确定不需要使用上下文，就建议await后面都加上```.ConfigureAwait(false)```，这么做对于GUI界面的好处更加显著，比如一个用户进行非常密集的操作，如果所有的按钮点击都使用同一个同步上下文等待恢复执行await后续代码，那么前端界面会出现卡顿的情况。

### 异步方法返回值建议使用“Task”而不是void

看一下上面的代码，如果你调用***SaveUser***保存用户，那么catch中永远捕获不到异常。

```c#
public async void SaveUserToDB(UserInfo user)
{
    throw new Exception();
}
/// 根据userId获取用户信息
public async Task SaveUser(stirng userId)
{
    try
    {
        await SaveUserToDB(userId);
    }
    catch (System.Exception)
    {
        // 在这里你永远捕获不到异常
    }
}
```

上面的代码为什么捕获不到异常呢？其实是因为异步方法对于error的捕获形式不同，他是把异常捕获之后放到Task的对象中的，所以你的异步方法都没有返回的Task对象，必然就捕获不到异常，这个异常会一直被向上抛，直到被一个同步上下文接收到。

那么除了用于捕获异常，通过返回Task来替代返回void的异步方法还有以下两点好处：

1. 提供后续操作，你可以取得异步方法的返回值然后做后续操作，比如WhenAny、WhenAll等
2. 便于测试，因为MSTest的异步测试只支持返回Task或者Task<T>的方法。

那么异步方法返回void是不是没用了？其实返回void的异步方法是有特殊用意的，他是给事件使用的，对于WinForm或者WPF这种UI系统，一是因为对于C/S程序，异常可以直接被最上层的同步上下文，由他来决定怎么处理，二是因为这个方法通常都是private的，所以也不需要进行测试。下面是官网给出的一个按钮点击事件的代码，

```c#
// SynchronizationContext
// 这是界面按钮点击事件的方法，通常不需要测试这个方法本身
private async void button1_Click(object sender, EventArgs e)
{
  await Button1ClickAsync();
}
public async Task Button1ClickAsync()
{
  // Do asynchronous work.
  await Task.Delay(1000);
}
```

***Note：上面只列举了一些简单用法和最佳实践，如果需要更多用法，建议参考微软官方文档***
